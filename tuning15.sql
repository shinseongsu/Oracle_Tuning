-- 조인별 방식별 특성 비교

-- NL 조인의 가장 큰 장점은 '중간에 멈출 수 있다'
-- NL 조인과 관련하여 튜닝을 하다보면 아주 극적인 성능 개선이 이뤄지는 경우가 꽤 있습니다.

-- 반대로 NL 조인의 단범은 조인을 시도할 때, 랜덤 액세스 부하가 매우 높다는 점입니다.
-- 드라이빙 테이블에서 만족하는 결과가 많은 경우, Inner 테이블에 조인 커럼과 관련 인덱스가 없을 경우에는 드라이빙 테이블의 결과 건수만큼 반복해서 읽어야 하는 엄청난 단점이 있다.


-- 소트 머지 조인은 Outer 테이블에 정렬을 대신할 인덱스가 있다면 정렬을 시도하지 않습니다.
-- 이럴 경우 Inner 테이블의 크기가 작다면 마찬가지로 정렬에 대한 부담도 줄어듭니다.

-- Outer 테이블에 정렬을 대신할 인덱스는 없지만, 테이블 자체를 조인 시도하는게 아닌 인라인 뷰로 만들어진 Group by나 Order by 등으로 이미 정렬된 상태라면,
-- 이때에도 정렬을 추가로 시도하지 않습니다.


-- 그런데 NL 조인을 사용하기에는 너무 많은 랜덤 액세스가 부담스럽고, 조인 조건이 등치(=) 조건이 아닌경우 소트 머지 조인을 사용할 수 있습니다.
-- 또한 소트 머지 조인도 첫번째 테이블에 한해 중간에 멈출 수 있습니다.
-- 두번쨰 테이블은 전체를 정렬시켜 놓은 상태에서 조인을 시도하지만, 첫번째 테이블은 정렬을 대신할 인덱스가 있다면 미리 정렬하지 않고 해당 인덱스를 이용하지만,
-- 첫번째 테이블은 정렬을 대신할 인덱스가 있다면 미리 정렬하지 않고 해당 인덱스를 이용해 실시간으로 스캔해 조인을 시도합니다.
-- 이 경우에는 중간에 멈춤 조건이 있을 경우 부분범위처리를 할 수 있습니다.

-- 마지막으로 해시 조인은 조인을 시도할 때, NL 조인처럼 랜덤 액세스 부하가 있는것도 아니고
-- 소트 머지 조인처럼 정렬을 하는 부담도 없습니다.
-- 다만 해시 맵을 만들어야 하는 부담은 있습니다.

-- 전체 테이터를 정렬하는 것보다 해시 버킷을 만들어 놓고, 테이블을 스캔하면서 해당 버킷에 연결만 시키는 과정이 좀 더 부하가 낮을 것입니다.
-- 그렇지만 해시맵도 PGA 내 해시영역에 생성되므로 크기가 작을 때 더욱 유리합니다.

-- 해시 함수는 같은 값이 입력되면 반환 값도 같으므로, 조인키 값의 Distinct Value 수와 전체 값의 수가 큰 차이를 보이면 심각한 성능 저하가 발생할 수 있다.
-- 조인컬럼의 값에 중복 값이 적거나 where 절에 조인컬럼 값을 걸러내는 필터 조건이 없어야 합니다.

select ...
from   ...
where A.KEY = B.KEY
and   B.KEY = 30;

-- B 테이블에 Build Input 이라면 하나의 버킷에 해시 체인이 연결될 것입니다.
-- 이런경우 라면 해시 조인이 좋지 않습니다.


select ...
from   ...
where A.KEY = B.KEY

-- 실제 값에 중복되는 경우가 많다면, 이런 경우 해시 조인은 극심한 성능 저하를 가져옵니다.

-- 또한 소트 머지 조인과 해시 조인은 정렬과정과 해시 맵을 만드는 과정에서 많은 양의 CPU 부하를 가져옵니다.
-- NL 조인으로 처리할 수 있음에도 해시 조인으로 처리하면 간단하게 성능 향상 효과가 나타나ㅣㄱ 떄문에 해시 조인을 여기저기 마구 사용하는 경향이 있습니다.
-- 그럴경우 CPU 부하가 발생해 시스템 전체적으로 영향을 미치게 됩니다.



-- NL 조인
--> 온라인 트랜잭션이 많고 부분범위처리(페이징에 사용)가 가능할 때
--> 각 테이블의 데이터는 많지만 추출 대상이 되는 데이터 양이 많지 않을 때


-- 소트 머지 조인
--> 첫 번째 테이블에 조인 컬럼 기준으로 인덱스가 있어 정렬 부하가 발생하지 않을 때
--> Group by 나 Order by 등으로 이미 정렬한 서브 쿼리와 조인 시도 시 두 번째 테이블의 양이 적을 때
--> 테이블의 양이 양이 매우 커서 NL 조인이 힘들고, 조건이 등치(=) 조인이 아니어서 해시 조인도 사용하기 힘들 때


-- 해시 조인
--> 대용량 테이블을 조인 시도하는데 조인 컬럼에 적당한 인덱스가 없어 NL 조인이 힘들 때
--> 조인 컬럼에 인덱스가 있지만 드라이빙 테이블의 결과 건수가 많아 Inner 테이블로 많은 양의 랜덤 액세스가 발생할 때
--> 두 테이블의 양이 많아 소트 머지 조인 시도 시 정렬로 인한 부하가 클 때





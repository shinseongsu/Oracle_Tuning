-- 파티셔닝

-- 파티셔닝은 물리적 데이터를 논리적으로 나눈다는 의미입니다.

-- 테이블 파티셔닝

-- 테이블을 파티셔닝하면 논리적으로는 테이블로 접근하지만 물리적으로는 테이블 내의 각각의 파티션으로 접근합니다.
-- 각각의 파티션은 데이터 저장 구조에서 설명한 세그먼트에 해당합니다.
-- 파티션 테이블을 제외하고 테이블을 제외하고 테이블과 거의 1:1 구조라고 언급했었는데 파티션 테이블은 파티션과 세그먼트가 1:1 구조입니다.

-- 테이블 파티션은 테이블 데이터를 일정 기준으로 나누어 저장하는 것인데, 일상 생활에서도 일정 기준으로 나누어 보관하는 것을 흔하게 볼 수 있습니다.
-- 데이터를 이렇게 나누어 보관하면 아무래도 관리가 더 쉽습니다.
-- 사용자 관점에서 보면 서점에서 책을 찾을 때와 마찬가지로 범위를 줄여 원하는 데이터가 위치한 파티션만 읽도록 합니다.
-- 전체 테이블 데이터를 모두 읽지 않아 뛰어난 성능을 기대할 수 있습니다.
-- 관리 관점에서도 많은 데이터를 보관하다가 더 이상 보관할 필요가 없는 데이터를 삭제하려고 할 때 해당 파티션만 지우면 됩니다.

-- 데이터를 삭제할 때도, 파티션으로 나누어 보관했다면 해당 파티션을 DDL 구문을 이용해 빠르고 쉽게 삭제할 수 있습니다.

-- 데이터를 파티션 단위로 보관하기 때문에 추가, 삭제, 변경을 매우 빠르고 쉽게 할 수 있습니다.
-- DELETE 구문을 사용하는 것과 단순히 파티션을 드롭하는 것은 수행 속도 뿐 아니라 그와 관련한 여러 관리 측면에서도 이점이 있습니다.


-- 리스트 파티션 : 파티션 키 컬럼이 값으로 지정됨
-- RANGE 파티션 : 파티션 키 컬럼이 값의 범위로 지정됨
-- 해시 파티션 : 파티션 키 컬럼의 값을 오라클 내부에 지정함.



-- RNAGE 파티션

-- Range 파티션은 파티션을 나눌 때 가장 일반적으로 쓰입니다.
-- 주로 쌓이는 날짜를 기준으로 파티션합니다.
-- 파티션 키 컬럼을 정하기 매우 쉽다는 장점이 있습니다.

create table ORD_RANGE (
    ORD_NO    NUMBER(10)    NOT NULL,
    ORD_DT    VARCHAR2(8)   NOT NULL,
    ORD_HMS   VARCHAR2(6),
    SHOP_NO   VARCHAR2(10),
    ...
)
PATITION BY RANGE (ORD_DT) 
(
    PARTITION P201201 VALUES LESS THAN ('201202')
  , PARTITION P201202 VALUES LESS THAN ('201203')
  , PARTITION P201203 VALUES LESS THAN ('201204')
  , PARTITION P201204 VALUES LESS THAN ('201205')
  , PARTITION P201205 VALUES LESS THAN ('201206')
  , PARTITION P201206 VALUES LESS THAN ('201207')
  , PARTITION P201207 VALUES LESS THAN ('201208')
  , PARTITION P201208 VALUES LESS THAN ('201209')
  , PARTITION P201209 VALUES LESS THAN ('201210')
  , PARTITION P201210 VALUES LESS THAN ('201211')
  , PARTITION P201211 VALUES LESS THAN ('201212')
  , PARTITION P201212 VALUES LESS THAN ('201213')
  , PARTITION P_DEFAULT VALUES LESS THAN (MAXVALUE)
);

-- 위의 첫 파티션을 보면 파티션 명은 P201201이라는 이름을 가지고 있는데 LESS THAN('201202') 구문은 201202값을 가지고 있습니다.
-- 이 경우 P201201 파티션에는 201202보다 작은 값이 들어올 수 있습니다.
-- 이경우는 201202보다 작은 값이 들어올 수 있다.
-- 마지막 라인은 P_DEFAULT 파티션에 MAXVALUE 값으로 만들어 두면 파티션을 추가해야 하는데, 미처 못했을 경우 에러가 나는 상황을 방지하고자 할 때 사용할 수 있습니다.

-- Range 파티션의 가장 큰 특징은 파티션 키 컬럼의 값이 범위를 가지고 있다는 것입니다.
-- 키 컬럼 자체가 연속성이 있는 데이터를 갖는 특징이 있기 때문에, 파티션 키 컬럼을 가지고 부등호 연산이나 BETWEEN 연산을 했을 경우 해당 파티션 몇 개만 읽을 수 있습니다.

WHERE ORD_DT BETWEEN '20120115' AND '20120125'   -- 1월 파티션만 읽어 처리



-- 리스트  파티션

-- 리스트 파티션은 키 컬럼의 값이 설정한 값과 일치할 경우에 사용합니다.

create table BILL_LIST (
    BILL_NO      NUMBER(10)     NOT NULL
  , BILL_YM      VARCHAR2(6)    NOT NULL  /*+ 청구년월  */
  , MEMBER_ID    VARCHAR2(10)
  , ....  
)
PARTITION BY LIST(BILL_YM)
(
    PARTITION P201201 VALUES ('201201')
  , PARTITION P201202 VALUES ('201202')
  , PARTITION P201203 VALUES ('201203')
  , PARTITION P201204 VALUES ('201204')
  , PARTITION P201205 VALUES ('201205')
  , PARTITION P201206 VALUES ('201206')
  , PARTITION P201207 VALUES ('201207')
  , PARTITION P201208 VALUES ('201208')
  , PARTITION P201209 VALUES ('201209')
  , PARTITION P201210 VALUES ('201210')
  , PARTITION P201211 VALUES ('201211')  
  , PARTITION P201212 VALUES ('201212')
  , PARTITION P_DEFAULT VALUES (DEFAULT)
);

-- 1월 데이터에 청구년월의 1월에 해당하는 값을 입력하도록 한 것입니다.
-- 청구년월이 모두 같은 값이므로 리스트 파티션이 조금 더 유리합니다.

-- 리스트 파티션에 대한 또 다른 예제를 보곘습니다.

create table 판매도서_LIST (
    도서번호     NUMBER(10)    NOT NULL
  , 도서카테고리  VARCHAR2(6)   NOT NULL
  , 판매자ID     VARCHAR2(10)
  , ...  
)
PARTITION BY LIST(도서카테고리)
(
    PARTITION P_카테고리01 VALUES ('소설', '문학')
  , PARTITION P_카테고리02 VALUES ('경제', '경영', '재테크')
  , PARTITION P_카테고리03 VALUES ('사회', '과학')
  , PARTITION P_DEFAULT VALUES (DEFAULT)
);

-- 분류를 잘못하면 특정 파티션에 데이터에 데이터가 몰릴 수 있습니다.
-- 이러한 상황에서 조회할 경우 연관성이 높지 않아 여러 파티션에 데이터가 몰릴 수 있습니다.
-- 이러한 상황에서 조회할 경우 연관성이 높지 않아 여러 파티션을 읽어야 하는 경우가 발생합니다.
-- 따라서 직접 분류할 경우애는 주의해야 합니다.

WHERE 도서카테고리 IN ('경제', '경영', '재테크') -- 하나의 파티션에서 처리
WHERE 도서카테고리 IN ('소설', '경제', '사회')   -- 세 개의 파티션에서 처리


-- 해시 파티션

-- 해시(Hash) 파티션은 키 컬럼의 값을 해시 함수를 이용해 지정한 파티션의 개수로 나누어 저장합니다.
-- 리스트 파티션에서는 사람이 데이터를 분류한다면, 해시 파티션은 오라클이 해시 함수로 데이터를 분산시켜 줍니다.
-- 대신 키 컬럼을 정할 때, 데이터 분포를 고려해야 합니다.

Create table ORD_HASH (
    ORD_NO    NUMBER (10)    NOT NULL,
    ORD_DT    VARCHAR2 (8),
    ORD_HMS   VARCHAR2 (6),
    SHOP_NO   VARCHAR2 (10),
    ....
)
PARTITION BY HASH (ORD_NO) PARTITIONS 8;

-- 해시 파티션을 사용하게 된다면 가급적 같은 값이 많지 않은 컬럼을 사용해야 효과를 볼 수 있습니다.
-- 또한 해시 조인과 마찬가지로 등치(=) 조건과 IN 조건으로만 사용할 수 있고 범위 조건인 부등호 조건과 BETWEEN 조건으로 사용될 가능성이 있는 컬럼은 되도록 사용하지 않는 것이 좋습니다.
-- 위에서도 키 컬럼으로 주문일자(ORD_DT)를 이용하보다는 주문번호를 이용한것은 이러한 이유 때문입니다.



-- 세 가지 파티션 특징

-- 우선 Range 파티션은 가장 상식적입니다.
-- 파티션을 만들려고 하는 테이블은 우선 데이터가 많기 때문인데 RANGE 파티션은 파티션키 컬럼을 정하기 쉽고, 기 기준을 월이든 분기든 각 파티션의 데이터의 분포가 갑자기 폭발적인 인기가 나왔다 사라지지 않는 어느정도 비슷합니다.

-- 리스트 파티션은 위에서 RANGE 파티션과 비슷한 예제를 보지 않으셨다면 키 컬럼을 잡기가 매우 어려울 것입니다.
-- 실무에서도 주로 지역(서울, 경기, 강원 등) 컬럼이나 업무적으로 사용하는 카테고리 같은 컬럼을 사용하는데, 데이터 분포를 사람이 맞춰야 하기 때문에 각 파티션마다 분포가 크게 차이 날 수도 있습니다.

-- 해시 파티션은 다른 파티션과 달리 문법적으로 파티션 개수만 지정한 것외에는 특별한 것도 없습니다.
-- 그래서 오라클은 복합 파티션이라는 기능을 제공합니다.
